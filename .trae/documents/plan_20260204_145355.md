# 后端实现计划 (Python + FastAPI + SQLite)

收到，已将技术栈调整为 **Python + FastAPI**。

## 1. 后端存储方案分析与推荐

**推荐方案：SQLite + SQLModel**

*   **原因**：
    *   **SQLModel**: 由 FastAPI 作者开发，完美结合了 SQLAlchemy (ORM) 和 Pydantic (数据验证)，非常适合 FastAPI 项目。
    *   **SQLite**: 依然是最佳选择，无需配置，支持 JSON 存储（适合你的 `outline` 和 `chapters` 结构），直接支持 Base64 字符串存储。

## 2. 技术栈
*   **Language**: Python
*   **Framework**: FastAPI (高性能，自动生成文档)
*   **Server**: Uvicorn
*   **Database**: SQLite
*   **ORM**: SQLModel
*   **Auth**: python-jose (JWT), passlib (密码哈希)

## 3. 实施步骤

### 第一步：环境配置
1.  创建 `requirements.txt`，包含 `fastapi`, `uvicorn`, `sqlmodel`, `python-jose[cryptography]`, `passlib[bcrypt]`。
2.  创建基本的项目结构。

### 第二步：数据模型 (SQLModel)
1.  **转换类型**：将 `types.ts` 中的 TypeScript 接口转换为 Python 的 Pydantic/SQLModel 类。
    *   `User`: 对应用户表。
    *   `Book`: 对应书籍表。
    *   **JSON 字段处理**：`BookRequirement`, `ChapterOutline`, `ChapterContent` 等嵌套结构将利用 SQLModel (SQLAlchemy) 的 `JSON` 类型列进行存储，这能完美保持数据结构的灵活性。
    *   **Base64 图片**：`coverImage` 字段定义为 `Text` 类型。

### 第三步：API 接口实现
1.  **认证模块 (`/auth`)**
    *   实现 `POST /auth/register` 和 `POST /auth/login`。
    *   使用 JWT (Bearer Token) 进行身份验证。
    *   (可选) 简单实现 `verify` 接口。
2.  **图书模块 (`/books`)**
    *   实现 `GET`, `POST`, `PUT`, `DELETE` 接口。
    *   **依赖注入**：使用 FastAPI 的 `Depends` 获取当前登录用户，确保用户只能访问自己的书籍。
    *   **Base64 处理**：Pydantic 模型将自动处理请求体中的 Base64 字符串验证。

### 第四步：验证
1.  创建一个 `test_api.py` 脚本，使用 `fastapi.testclient` 进行集成测试。
2.  验证注册、登录、创建带封面的书籍、获取列表等核心流程。

请确认是否同意此更新后的计划？